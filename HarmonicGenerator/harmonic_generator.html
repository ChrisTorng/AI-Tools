<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泛音生成器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; }
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        button { margin: 5px; padding: 5px 10px; }
        .slider { width: 100%; }
        canvas { border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const noteFrequencies = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
            'G4': 392.00, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25
        };

        const HarmonicGenerator = () => {
            const [fundamental, setFundamental] = React.useState(440);
            const [harmonics, setHarmonics] = React.useState([
                { amplitude: 1, enabled: true },
                { amplitude: 0.5, enabled: true },
                { amplitude: 0.25, enabled: true },
                { amplitude: 0.125, enabled: true },
                { amplitude: 0.0625, enabled: true },
            ]);
            const [audioContext, setAudioContext] = React.useState(null);
            const [oscillator, setOscillator] = React.useState(null);
            const [gainNode, setGainNode] = React.useState(null);
            const [isPlaying, setIsPlaying] = React.useState(false);
            const canvasRef = React.useRef(null);

            React.useEffect(() => {
                const newAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                setAudioContext(newAudioContext);

                return () => {
                    if (newAudioContext) {
                        newAudioContext.close();
                    }
                };
            }, []);

            const createOscillator = React.useCallback(() => {
                if (audioContext) {
                    const newOscillator = audioContext.createOscillator();
                    const newGainNode = audioContext.createGain();
                    
                    updateOscillator(newOscillator);
                    
                    newOscillator.connect(newGainNode);
                    newGainNode.connect(audioContext.destination);

                    newOscillator.start();
                    setOscillator(newOscillator);
                    setGainNode(newGainNode);

                    return () => {
                        newOscillator.stop();
                        newOscillator.disconnect();
                        newGainNode.disconnect();
                    };
                }
            }, [audioContext, fundamental, harmonics]);

            React.useEffect(() => {
                let cleanup;
                if (audioContext && isPlaying) {
                    cleanup = createOscillator();
                }
                return () => {
                    if (cleanup) cleanup();
                };
            }, [audioContext, createOscillator, isPlaying]);

            const updateOscillator = (osc = oscillator) => {
                if (osc && audioContext) {
                    const real = new Float32Array([0, ...harmonics.map(h => h.enabled ? h.amplitude : 0)]);
                    const imag = new Float32Array(real.length).fill(0);
                    const wave = audioContext.createPeriodicWave(real, imag, { disableNormalization: true });
                    osc.setPeriodicWave(wave);
                    osc.frequency.setValueAtTime(fundamental, audioContext.currentTime);
                    drawWaveform(real, imag);
                }
            };

            const handlePlayStop = () => {
                if (isPlaying) {
                    oscillator.stop();
                    setOscillator(null);
                    setGainNode(null);
                }
                setIsPlaying(!isPlaying);
            };

            const handleFundamentalChange = (newValue) => {
                setFundamental(parseFloat(newValue));
                updateOscillator();
            };

            const handleHarmonicChange = (index, newValue) => {
                const newHarmonics = harmonics.map((h, i) => 
                    i === index ? { ...h, amplitude: newValue } : h
                );
                setHarmonics(newHarmonics);
                updateOscillator();
            };

            const handleHarmonicToggle = (index) => {
                const newHarmonics = harmonics.map((h, i) => 
                    i === index ? { ...h, enabled: !h.enabled } : h
                );
                setHarmonics(newHarmonics);
                updateOscillator();
            };

            const setPresetWaveform = (type) => {
                let newHarmonics;
                switch (type) {
                    case 'sine':
                        newHarmonics = [{ amplitude: 1, enabled: true }, ...Array(4).fill({ amplitude: 0, enabled: false })];
                        break;
                    case 'square':
                        newHarmonics = [
                            { amplitude: 1, enabled: true },
                            { amplitude: 0, enabled: false },
                            { amplitude: 1/3, enabled: true },
                            { amplitude: 0, enabled: false },
                            { amplitude: 1/5, enabled: true }
                        ];
                        break;
                    case 'sawtooth':
                        newHarmonics = [
                            { amplitude: 1, enabled: true },
                            { amplitude: 1/2, enabled: true },
                            { amplitude: 1/3, enabled: true },
                            { amplitude: 1/4, enabled: true },
                            { amplitude: 1/5, enabled: true }
                        ];
                        break;
                    default:
                        return;
                }
                setHarmonics(newHarmonics);
                updateOscillator();
            };

            const drawWaveform = (real, imag) => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();
                ctx.moveTo(0, height / 2);

                for (let i = 0; i < width; i++) {
                    let t = i / width * Math.PI * 2;
                    let y = 0;
                    for (let n = 1; n < real.length; n++) {
                        y += real[n] * Math.cos(n * t) - imag[n] * Math.sin(n * t);
                    }
                    y = -y * height / 4 + height / 2;
                    ctx.lineTo(i, y);
                }

                ctx.strokeStyle = 'blue';
                ctx.stroke();
            };

            return (
                <div className="container">
                    <h2>高級互動式泛音生成器</h2>
                    <div>
                        <button onClick={handlePlayStop}>
                            {isPlaying ? "停止" : "播放"}
                        </button>
                        <select onChange={(e) => handleFundamentalChange(e.target.value)} value={fundamental}>
                            {Object.entries(noteFrequencies).map(([note, freq]) => (
                                <option key={note} value={freq}>{note} ({freq} Hz)</option>
                            ))}
                        </select>
                    </div>
                    <div>
                        <button onClick={() => setPresetWaveform('sine')}>正弦波</button>
                        <button onClick={() => setPresetWaveform('square')}>方波</button>
                        <button onClick={() => setPresetWaveform('sawtooth')}>鋸齒波</button>
                    </div>
                    {harmonics.map((harmonic, index) => (
                        <div key={index}>
                            <label>
                                第 {index} 泛音 ({(index + 1) * fundamental} Hz): {harmonic.amplitude.toFixed(2)}
                            </label>
                            <input
                                type="range"
                                min="0"
                                max="1"
                                step="0.01"
                                value={harmonic.amplitude}
                                onChange={(e) => handleHarmonicChange(index, parseFloat(e.target.value))}
                                disabled={!harmonic.enabled}
                                className="slider"
                            />
                            <input
                                type="checkbox"
                                checked={harmonic.enabled}
                                onChange={() => handleHarmonicToggle(index)}
                            />
                        </div>
                    ))}
                    <canvas ref={canvasRef} width="400" height="200" />
                </div>
            );
        };

        ReactDOM.render(<HarmonicGenerator />, document.getElementById('root'));
    </script>
</body>
</html>